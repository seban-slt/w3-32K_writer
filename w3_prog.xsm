		opt	h+

; Atari OS defs

ClrScr		equ	$7d
EoF		equ	$88
EoL		equ	$9b
Bell		equ	$fd

; OS CIO defs

icchid		equ	$0340
icdno		equ	$0341
iccmd		equ	$0342
icstat		equ	$0343
icbufa		equ	$0344
icputb		equ	$0346
icbufl		equ	$0348
icax1		equ	$034a
icax2		equ	$034b
icax3		equ	$034c
icax4		equ	$034d
icax5		equ	$034e
icax6		equ	$034f

cio		equ	$e456

; CIO commands

CIO_OPEN	equ	$03
CIO_GET_RECORD	equ	$05
CIO_GET_BYTES	equ	$07
CIO_PUT_RECORD	equ	$09
CIO_CLOSE	equ	$0c
CIO_STATUS	equ	$0d

; OS registers

RT_CLOCK	equ	$14
COLBACK		equ	$2c8

TRIG3		equ	$d013

; zero page	

ptr		equ	$80

; colours

BLACK		equ	$00
RED		equ	$20

; prog defs

NULL		equ	0

max_txt_len	equ	$100
line_buff	equ	$500
line_buff_len	equ	$80

fname_ptr	equ	$500
data_buff	equ	$2100
data_buff_len	equ	$7f00

; file structure starts here

		org	$d301
		dta	$ff
	
		org	$2000

boot_loader	ins	'loader.xex'
		ert	[*!=$2100]

		org	$a000

fill		org	*+$100

msg_welcome	dta	ClrScr,29,c"*** Weekend 3+ cart. writer v0.1 ***",EoL
		dta	c" - done by Seban/Slight, (p) 2019 -",EoL,EoL
		dta	c" alpha version! don't redistribute! "*,EoL,EoL,0
		
msg_hlp		dta	EoL,c"Available commands are:",EoL,0
msg_bad_cmd	dta	c"Unknown command, try HELP or ?",Bell,EoL
msg_cmd_notim	dta	c"Command not implemented yet ;/",Bell,EoL

; data structures for File/CIO commands:

file_open	dta	1,CIO_OPEN,4,0,a(line_buff)			; open #1,4,0,"dev:filemane.ext"
file_bget	dta	1,CIO_GET_BYTES,a(data_buff),a(data_buff_len)	; bget #1,data_buffer,data_buffer_len
file_close	dta	1,CIO_CLOSE					; close #1

; data structures for Editor/CIO commands:

e_devn		dta	c"E:",EoL					; editor device name
editor_close	dta	0,CIO_CLOSE					; close #0
editor_open	dta	0,CIO_OPEN,12,0,a(e_devn)			; open  #0,12,0,"E:"
editor_put	dta	0,CIO_PUT_RECORD,a(NULL),a(max_txt_len)		; print #0;"..."
editor_input	dta	0,CIO_GET_RECORD,a(line_buff),a(line_buff_len)	; input #0,line$

; set background colour

set_colback	sta	$2c8
;		jmp	vsync_wait		; jmp not needed when vsync_wait is next

; wait for vertical blank

vsync_wait	lda	RT_CLOCK
		cmp	RT_CLOCK
		beq	*-2
		rts
; screen editor	INIT

editor_init	ldx	<editor_close		; CLOSE #0 command struct
		ldy	>editor_close
		jsr	cio_parse_cmd		; exec CIO command
		
		ldx	<editor_open		; OPEN #0 command struct
		ldy	>editor_open
		jmp	cio_parse_cmd		; exec CIO command
		
; print line procedure
		
print		stx	editor_put+2		; store LO-byte of message address in data structure
		sty	editor_put+3		; store HI-byte of message address in data structure
		
		ldx	<editor_put		; PUT_LINE command struct
		ldy	>editor_put
		jmp	cio_parse_cmd		; exec CIO command

; print the null terminated string on console

printz		stx	prz_msg+1	; store message address direct in code body below
		sty	prz_msg+2
		
prz_msg		lda	$beee		; get msg char
		bne	*+3		; end of string?
		rts			; yes! back to caller
		
		jsr	put_c		; put char on console
		
		inc	prz_msg+1	; increment string address
		bne	*+5
		inc	prz_msg+2
		
		jmp	prz_msg

; put Bell procedure

os_bell		lda	#Bell			; ATASCII "Bell" code
		bne	put_c			; go to put char

; put EoL procedure

put_eol		lda	#EoL
;		jmp	put_c			; jmp don't needed if put-char proc is next after this proc.

; put char procedure

put_c		ldx #$00			; channel #0
		tay               
		lda icputb+1,x			; push address of OS put-char procedure on stack
		pha
		lda icputb+0,x
		pha
		tya				; byte to write must be in A reg.
		rts

; print hex procedure

put_hex		pha
		lsr	@
		lsr	@
		lsr	@
		lsr	@
		jsr	to_hex
		pla
		and	#$0f
to_hex		cmp 	#$0a
		sed
		adc 	#'0'
		cld
		jmp	put_c

; BIN2DEC procedure

bin_dec8	sta	product
		lda	#0
		sta	digits+0
		sta	digits+1

		ldy	#7
		sed				; do a binary to decimal conversion
bd0		asl	product

		lda	digits+0
		adc	digits+0
		sta	digits+0

		lda	digits+1
		adc	digits+1
		sta	digits+1

		dey
		bpl	bd0
		cld
		rts

product		dta	$00
digits		dta	$00,$00

; prints out the "welcome message on screen

welcome_msg	ldx	<msg_welcome		; print welcome message
		ldy	>msg_welcome
		jmp	printz

; show the command line prompt

cmd_prompt	ldx	#<pr_line
		ldy	#>pr_line
		jmp	printz

pr_line		dta	c"CMD>",0

; procedure gets the user input from console

get_cmd_line	ldx	<editor_input		; call INPUT command line
		ldy	>editor_input
		jsr	cio_parse_cmd		; exec CIO command
		
		lda	editor_input		; get CIO channel # from struct
		asl	@			; calculate channel index
		asl	@
		asl	@
		asl	@
		tax				; move to X reg.
		lda	icbufl+0,x		; return with record length in A & Y regs.
		ldy	icbufl+1,x
		rts

; CIO struct parser

cio_parse_cmd	stx	ptr+0
		sty	ptr+1
		ldy	#$00
		
		lda	(ptr),y		; get CIO channel number
		asl	@
		asl	@
		asl	@
		asl	@
		tax
		iny
		
		lda	(ptr),y		; get CIO "command"
		sta	iccmd,x
		iny

		cmp	#CIO_CLOSE	; if CLOSE command then skip next data
		beq	cio_skp0

		cmp	#CIO_OPEN	; if not OPEN command skip AUX bytes setup
		bne	cio_skp1

		lda	(ptr),y		; get AUX1 value
		sta	icax1,x
		iny

		lda	(ptr),y		; get AUX2 value
		sta	icax2,x
		iny
				
cio_skp1	lda	(ptr),y		; get LO byte of buffer address
		sta	icbufa+0,x
		iny

		lda	(ptr),y		; get LO byte of buffer address
		sta	icbufa+1,x
		iny

		lda	iccmd,x		; chek for CIO OPEN command
		cmp	#CIO_OPEN
		beq	cio_skp0

		lda	(ptr),y		; get LO byte of buffer length
		sta	icbufl+0,x
		iny

		lda	(ptr),y		; get LO byte of buffer length
		sta	icbufl+1,x

cio_skp0	jsr	cio		; call system CIO routine
		bpl	cio_OK
		php
		cpy	#EoF
		beq	cio_eof
		
cio_err		lda	#RED		; when CIO error then set border color to RED
		jsr	set_colback
cio_eof		plp
cio_OK		rts

; procedure prints I/O error message, with CIO error code converted to decimal

CIO_print_error	tya			; move	error code to A reg.
		jsr	bin_dec8	; convert to decimal
		
		ldx	#<cio_msg_err	; set address of error message
		ldy	#>cio_msg_err
		jsr	printz		; print error message

		lda	digits+1	; print out HI-byte of error code
		jsr	put_hex
		lda	digits+0	; print out LO-byte of error code
		jsr	put_hex
		jsr	put_eol		; add end of line marker
		sec			; set CARRY (signals error condition for caller)
		rts			; return

cio_msg_err	dta	$9b,c"I/O error #",0

; command table

cmds		dta	EoL,0,a(cmd_rts-1)
		dta	c"?",0,a(cmd_help-1)
		dta	c"HELP",0,a(cmd_help-1)
		dta	c"DOS",0,a(cmd_dos-1)
		dta	c"CLS",0,a(cmd_cls-1)
		dta	c"DIR",0,a(cmd_dir-1)
		dta	c"LOAD",0,a(cmd_load-1)
		dta	c"VERIFY",0,a(cmd_verify-1)
		dta	c"PROG",0,a(cmd_prog-1)
		dta	$ff				

; -----------------------------------------------------------------------------
; "DOS" command

cmd_dos		jmp	($0a)

; -----------------------------------------------------------------------------
; "CLS" command, and "null entry" command

cmd_cls		jsr	welcome_msg		; re-print the welcome-msg!
cmd_rts		lda	#BLACK			; set border colour to black!
		jsr	set_colback
		clc				
		rts

; -----------------------------------------------------------------------------
; "HELP" command

cmd_help	ldx	<msg_hlp		; print-out help message
		ldy	>msg_hlp
		jsr	printz
		
		ldx	#$00			; clear X reg. (compare table index)

cmhl_loop	lda	cmds,x			; get char from table
		beq	cmhl_skp		; jump if end of string!
		cmp	#EoL			; check for EoL
		bne	cmhl_nxt		; proceed char

		inx				; EoL/NULL "entry" detected, skip to next entry by advancing index
		inx
		inx
		inx
		bne	cmhl_loop		; do the loop!
		
cmhl_nxt	stx	cm_stx0+1		; store X reg.

		jsr	put_c			; put char 

cm_stx0		ldx	#0			; restore index
		inx				; advance index
		bne	cmhl_loop		; do the loop
		
cmhl_skp	inx				; skip address, advance to next table entry!
		inx
		inx
		
		lda	cmds,x			; end of table?
		bmi	cmhl_done		; yes! jump to exit
		
		stx	cm_stx1+1		; store X reg.
		
		lda	#','			; print out separator
		jsr	put_c
		lda	#' '
		jsr	put_c

cm_stx1		ldx	#0			; restore X reg.
		jmp	cmhl_loop		; do the loop
		
cmhl_done	jsr	put_eol
		clc
		rts

; -----------------------------------------------------------------------------
; "DIR" command

dir_open	dta	1,CIO_OPEN,6,0,a(line_buff)			; open #1,4,0,"dev:filemane.ext"
dir_get_entry	dta	1,CIO_GET_RECORD,a(line_buff),a(line_buff_len)	; input #1,entry$
dir_def_spec	dta	c"D:*.*",EoL

cmd_dir		txa				; save X reg.
		pha				; ... on stack

		ldx	#>line_buff		; load HI-byte of line buffer to X reg.

		lda	line_buff,y		; check if the "DIR" command has additional input
		cmp	#EoL			; ... EoL at entry pointer means no additional parameters!
		bne	dir_not_eol		; not EoL so, there is user parmaters after the DIR command...

		ldy	#<dir_def_spec		; ... EoL detected, so load the default DIR filespec.
		ldx	#>dir_def_spec

dir_not_eol	sty	dir_open+4		; update dir filespec pointer!
		stx	dir_open+5		

		pla				; restore X reg.
		tax
		
		lda	line_buff-2,x		; check buffer
		cmp	#':'			; if ":" at end of buffer...
		beq	dir_add			; add *.* to the dir filespec
		cmp	#'>'			; or maybe ">" (subdir mark) at end of buffer?
		bne	dir_dont_add		; no, so don't add *.* to the filespec

dir_add		ldy	#0			; clear Y reg. (loop counter)
dir_cpl		lda	dir_def_spec+2,y	; copy from default dir filespec "*.*"
		sta	line_buff-1,x		; ...to user input buffer
		inx				; advance X index
		iny				; advance Y index
		cpy	#$04			; all chars copied?
		bcc	dir_cpl			; nope, do the loop!

dir_dont_add	ldx	#<dir_open		; open I/O channel for directory
		ldy	#>dir_open
		jsr	cio_parse_cmd		; exec CIO command
		bpl	dir_open_ok
		
dir_cio_err	jsr	CIO_print_error
		jmp	dir_cmd_done

dir_open_ok	
dir_loop	ldx	#<dir_get_entry
		ldy	#>dir_get_entry
		jsr	cio_parse_cmd
		cpy	#EoF
		beq	dir_no_more
		bmi	dir_cio_err
		
		ldx	#<line_buff
		ldy	#>line_buff
		jsr	print
		
		jmp	dir_loop
				
dir_no_more	jsr	cmd_rts
	
dir_cmd_done	ldx	#<file_close		; close I/O channel
		ldy	#>file_close
		jsr	cio_parse_cmd
		clc
		rts

; -----------------------------------------------------------------------------
; LOAD command

cmd_load	sty	file_open+4		; update filespec pointer!

		jsr	clear_file_len		; clear file len, and "valid file" flag
		jsr	clear_file_area		; clear the data buffer

		ldx	#<file_open		; try to "open" selected file
		ldy	#>file_open
		jsr	cio_parse_cmd		; exec CIO command
		bpl	load_open_ok		; opened succesfully?

load_cio_err	jsr	CIO_print_error		; print error message
		jmp	cmd_load_done		; finish processing

load_open_ok	ldx	#<file_bget		; load selected file
		ldy	#>file_bget
		jsr	cio_parse_cmd		; exec CIO command
		cpy	#EoF			; check for "end of file" status
		beq	load_ok			; Yes! EoF detected, file loaded OK!
		bmi	load_cio_err		; any other negative value? 

		ldx	#<msg_to_long		; file to long message printout
		ldy	#>msg_to_long
		jsr	printz
		jmp	cmd_load_done		; finish processing

load_ok		lda	file_open		; file loaded OK, check the data size
		asl	@
		asl	@
		asl	@
		asl	@
		tax
		lda	icbufl+0,x		; get the LO-byte of loaded data size
		sta	file_len+0		; store
		lda	icbufl+1,x		; get the HI-byte of loaded data size
		sta	file_len+1		; store
	
		ldx	#<msg_loaded		; printout the "file loaded" message
		ldy	#>msg_loaded
		jsr	printz
		
		lda	#'$'			; print out the hex radix
		jsr	put_c
		
		lda	file_len+1		; print out the length of loaded file
		jsr	put_hex
		lda	file_len+0
		jsr	put_hex

		ldx	#<msg_bytes_in		; print out the rest of message.
		ldy	#>msg_bytes_in
		jsr	printz

		lda	data_buff+0
		and	data_buff+1
		cmp	#$ff
		beq	load_chk_next
		
		ldx	#<msg_not_dos		; print out warning message
		ldy	#>msg_not_dos
		jsr	printz
	
		jsr	clear_file_len		; clear the file length and file_valid flags!
		jmp	cmd_load_done

load_chk_next	inc 	file_valid
cmd_load_done	ldx	#<file_close		; close I/O channel
		ldy	#>file_close
		jsr	cio_parse_cmd		; parse CIO command

		clc				; clear CARRY (no error flag)
		rts				; return

clear_file_len	lda	#$00
		sta	file_len+0		; clear the "file length"
		sta	file_len+1
		sta	file_valid		; and the "file valid" flag
		rts

clear_file_area	ldx	#>data_buff_len		; load HI-byte of data buffer len

		lda	#<data_buff		; load LO-byte of data buffer address
		sta	ptr+0
		lda	#>data_buff		; load HI-byte of data buffer address
		sta	ptr+1

		lda	#$00			; zero to A reg. (fill byte)
		tay				; zero to Y reg. (page-byte counter)
		
clr_b0		sta	(ptr),y			; clear mam @ptr
		iny				; next byte
		bne	clr_b0			; loop till end of page
		dex				; decrement page counter
		bne	clr_b0			; loop until done
		rts


file_valid	dta	$00
file_len	dta	a($0000)

msg_to_long	dta	EoL,c"File to long!",Bell,EoL,0
msg_loaded	dta	EoL,c"File loaded, ",0
msg_bytes_in	dta	c" bytes in buffer.",EoL,0
msg_not_dos	dta	c" Not a Atari-DOS file! "*,Bell,EoL,EoL,0

; -----------------------------------------------------------------------------

cmd_prog	lda	file_valid
		bne	cmd_prog_OK
		ldx	<msg_no_file
		ldy	>msg_no_file
		jsr	print
		clc
		rts

msg_no_file	dta	c" No vaild file in buffer! "*,Bell,EoL

cmd_prog_OK	sei				; disable IRQ's
		inc	$d40e			; disable NMI
		lda	$d40b			; wait for scan-line #0
		bne	*-3
		sta	$d400			; disable ANTIC's DISPLAY-DMA
		dec	$d301
		
only_once	ldy	#0
		bne	cmd_no_copy
		inc	only_once+1
		
; copy OS-ROM font under RAM
		
		sty	ptr+0			; set pointer to OS-ROM character set address ($e000)
		lda	#$e0
		sta	ptr+1

		ldx	#$03			; OS-ROM font size if 1024 bytes (4 pages)
cmd_rcp		inc	$d301			; enable OS-ROM
		lda	(ptr),y			; get source byte
		dec	$d301			; disable OS-ROM
		sta	(ptr),y			; put at the same address but "under" OS-ROM
		iny				; inc. Y reg. (page loop counter)
		bne	cmd_rcp			; loop until done the page!
		inc	ptr+1			; next page
		dex				; decrement page counter
		bpl	cmd_rcp			; <0? no, then loop.

		ldx	#>[rel_loc_end-rel_loc]	; calculate how many pages copy from here to RAM under OS-ROM
cmd_cpl0	lda	org_loc,y		; get byte from source address
cmd_cpl1	sta	rel_loc,y		; move to reloc address
		iny				; next byte on page
		bne	cmd_cpl0		; page-copy loop
		inc	cmd_cpl0+2		; increment HI-byte of src address
		inc	cmd_cpl1+2		; increment HI-byte of dst address
		dex				; decr. X reg (page counter)
		bpl	cmd_cpl0		; <0? no, so do the copy-loop!

cmd_no_copy	jsr	cmd_prog_entry		; jump into relocated code

		inc	$d301			; enable OS-ROM
		lsr	$d40e			; restore NMI's (only VBL)
		cli				; restore IRQ's
		clc				; all OK!
		rts				; ... and return!
		
org_loc		equ	*

		org	r:$c000

rel_loc		equ	*

dlp		dta	$70,$70,$70,$42,a(scr0),$70
		dta	$42
info_line_a	dta	a(scr1),$00,$02,$70
		dta	$42
info_line_b	dta	a(scr_a0)

		dta	$70,$46,a(scrd),$70,$70,$70

		dta	$70,$46,a(scrb),$10
		dta	$4b,a($a000),$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b
		dta	$70,$46,a(scrc),$10
		dta	$4b,a($d500),$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b,$0b
		dta	$41,a(dlp)

;			  0123456789abcdef0123456789abcdef
scr0		dta	d' Weekend 3+ prog/verify module! '*
scr1		dta	d'Now set switch to write position'
		dta	d'then press RESET button on cart!'
scr2		dta	d' Cartridge presence dectected ! '
		dta	d'Press',2+64,d'SHIFT'*,22+64,d'key to program cart.'
scr3		dta	d' - TRIG3 state error detected - '*
		dta	d'cartridge suddenly disconnected!'
scr4		dta	d'Writting cartridge, please wait!'
prog_bar	dta	d'                                '

scr5		dta	d' Change switch to READ position '*
		dta	d' Waiting for proper Trig3 state '


scr_a0		dta	d'    waiting for user action!    '*
scr_a1		dta	d' Press ESC key for command line '
scr_a2		dta	d'           working...           '*
scr_a3		dta	d' Writing done, waiting for user '*

;			  0123456789abcdef
scrb		dta	d'$A000-$A0FF AREA'*
scrc		dta	d'$D500-$D5FF AREA'*
scrd		dta	d'TRIG3 VALUE: $__'*

; char table for progrss bar (ANTIC codes)
bar_char_tab	dta	$56,$59,$c2,$80		

hex_trig3	pha
		lsr	@
		lsr	@
		lsr	@
		lsr	@
		jsr	to_hex_t3
		pla
		and	#$0f
to_hex_t3	cmp 	#$0a
		sed
		adc 	#'0'-32+128
		cld
		sta	scrd,y
		iny
		rts

cmd_prog_entry	sei
		inc	$d40e
		lda	$d40b
		bne	*-3
		
		lda	$2c5
		jsr	set_color
		
		ldx	<dlp
		ldy	>dlp
		stx	$d402
		sty	$d403
		
		lda	#$21
		sta	$d400
		
		ldx	<scr1
		ldy	>scr1
		stx	info_line_a+0
		sty	info_line_a+1

trig3_wait_loop	jsr	show_trig3
		beq	trig3_det_ok

		jsr	is_ESC_pressed		; is ESC key pressed?
		bne	trig3_wait_loop		; no!
		rts				; return

trig3_det_ok	ldx	#<scr2			
		ldy	#>scr2
		stx	info_line_a+0
		sty	info_line_a+1

		lda	#$8a
		jsr	set_color

trig3_loop	lda	TRIG3
		bne	*+5
		jmp	trig3_error

		lda	$d20f
		and	#$08
		bne	trig3_loop
		
		lda	#$4a
		jsr	set_color
		
		ldx	#31
		lda	#0
prb_cl0		sta	prog_bar,x
		dex
		bpl	prb_cl0
	
		ldx	#<scr4			
		ldy	#>scr4
		stx	info_line_a+0
		sty	info_line_a+1

		ldx	#<scr_a2	
		ldy	#>scr_a2
		stx	info_line_b+0
		sty	info_line_b+1

		lda	#<data_buff		; set LO-byte of data buffer
		sta	ptr+0
			
		ldy	#0

prg_l0		ldx	#0
		lda	#>data_buff
		sta	ptr+1

prg_l1		lda	(ptr),y
		sta	$d500,y
		inc	ptr+1
		inx	
		bpl	prg_l1
		
		tya
		pha
		lsr	@
		lsr	@
		lsr	@
		tax
		tya
		lsr	@
		and	#$03
		tay
		lda	bar_char_tab,y
		sta	prog_bar,x
		
		pla
		tay
		iny
		bne	prg_l0

		ldx	#<scr5			
		ldy	#>scr5
		stx	info_line_a+0
		sty	info_line_a+1

		ldx	#<scr_a3	
		ldy	#>scr_a3
		stx	info_line_b+0
		sty	info_line_b+1

		lda	#$0a
		jsr	set_color
		
prg_wait_t3	jsr	show_trig3
		bne	prg_trig3_done
	
		lda	$d500
		sta	$d500
		sta	$d40a
		jmp	prg_wait_t3

prg_trig3_done	rts

; Trig3 error sub-routine

trig3_error	lda	#RED+$0a
		jsr	set_color
		
		ldx	#<scr3			
		ldy	#>scr3
		stx	info_line_a+0
		sty	info_line_a+1

		ldx	#<scr_a1	
		ldy	#>scr_a1
		stx	info_line_b+0
		sty	info_line_b+1

err_loop	jsr	show_trig3

		lda	$d40b			; make some noise
		asl	@
		sta	$d01f
		
		jsr	is_ESC_pressed		; check for ESC key!
		bne	err_loop		; no, do the loop!
		rts				; return

; this proc check for ESC key pressed without OS-ROM intercation!

is_ESC_pressed	lda	$d20f			; get POKEY keyboard status reg.
		and	#$04			; any key pressed?
		bne 	is_no_key		; no! jump!
		lda	$d209			; get POKEY scan code
		cmp	#$1c			; is that 'ESC' code?
is_no_key	rts

; shows TRIG3 state at info line

show_trig3	lda	TRIG3
		pha
		ldy	#$0e
		jsr	hex_trig3
		pla
		cmp	#$01
		rts

; sets the screen colours

set_color	pha
		lda	$d40b
		bne	*-3
		pla
		sta	$d016
		sta	$d017
		and	#$f0
		ora	#$04
		sta	$d018
		rts

rel_loc_end	equ *
		
		org	r:[rel_loc_end-rel_loc+org_loc]

cmd_verify	ldx	<msg_cmd_notim
		ldy	>msg_cmd_notim
		jsr	print
		clc
		rts

; -----------------------------------------------------------------------------
; this procedure is used to parse the user command line buffer

parse_input	sta	input_len_a+1		; store length of entered command line
		sta	input_len_b+1
		sta	input_len_c+1

		ldx	#$00			; clear the X reg. (cmd-table index)
pr_next		ldy	#$00			; clear the Y reg. (user input buffer index)
		
pr_loop		lda	cmds,x
		beq	pr_skp_wspace		; done? then jump to skip "white spaces"
		cmp	line_buff,y		; compare with user line buffer
		bne	pr_dont_match		; not equal! Try another command!
		inx				; advance index of cmd table
		iny				; advance index of line buffer
input_len_a	cpy	#$ff			; compare with entered line length?
		bcc	pr_loop			; ... less?
		beq	pr_loop			; ... or eual?
pr_not_found	sec				; all compares failed, command not found! return with CARRY set!
		rts
		
pr_dont_match	inx				; get next char in table
		lda	cmds,x			; end of keyword?
		bne	pr_dont_match		; yes! so command don't match!
		inx				; skip HI-byte of address
		inx				; skip LO-byte of address
		inx				; get next char from table
		lda	cmds,x			; end of command table? 
		bpl	pr_next			; no! check next command!
		sec				; yes, exit with carry set
		rts

pr_skp_wspace	lda	line_buff,y		; get char from command line buffer
		cmp 	#$20			; space?
		bne	parse_done		; no! so end skip-loop
		iny				; next char
input_len_b	cpy	#$ff			; end of chars in buffer?
		bcc	pr_skp_wspace		; no, do the skip-loop!

parse_done	lda	#$00			; set background colour to black
		jsr	set_colback

		lda	cmds+2,x		; put the HI-byte of command address on stack
		pha
		lda	cmds+1,x		; put the LO-byte of command address on stack
		pha
		
input_len_c	ldx	#0			; return with command line length in X reg.
		rts

; filler

fill_area_init	ldx	#$0f
fl0		lda	#$55
		sta	fill+$00,x
		sta	fill+$20,x
		sta	fill+$40,x
		sta	fill+$60,x
		sta	fill+$80,x
		sta	fill+$a0,x
		sta	fill+$c0,x
		sta	fill+$e0,x
		lda	#$aa
		sta	fill+$10,x
		sta	fill+$30,x
		sta	fill+$50,x
		sta	fill+$70,x
		sta	fill+$90,x
		sta	fill+$b0,x
		sta	fill+$d0,x
		sta	fill+$f0,x
		dex
		bpl	fl0
		rts

; program starts here

st		jsr	fill_area_init
		jsr	editor_init		; init the screen editor
		jsr	welcome_msg		; print out welcome message
	
main_loop	jsr	cmd_prompt		; print the prompt line
		
		jsr	get_cmd_line		; get command line
		jsr	parse_input		; parse command line
		bcc	parse_ok		; jump if parse ok

		ldx	<msg_bad_cmd		; command not found? print message.
		ldy	>msg_bad_cmd
		jsr	print

parse_ok	jmp	main_loop		; repeat till end of world! ;)
		
		run	st